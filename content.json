{"pages":[],"posts":[{"title":"基于Klee的内核测试用例自动生成","text":"title: 基于Klee的内核测试用例自动生成为单个内核文件生成测试用例使用klee的原因是：内核接口存在对单个结构体的校验难以通过。本文主要解决两个问题 编译内核单个文件 klee生成测试用例 编译内核单个文件提取clang对单个文件的编译命令，假设我们只关注xfrm_user.c文件的verify_newpolicy_info： bear命令提取整个内核的compdb 修改特定文件cflag 需要修改/新增的cflag: -g -c -emit-llvm：生成llvm bitcode -D__CLANG_STDINT_H=1 , -I /usr/local/include：解决klee和内核头文件冲突 拷贝xfrm_user.c到xfrm_user_klee.c，并替换编译命令中的目标文件，详情见附录 klee生成测试用例在xfrm_user_klee.c中添加如下 12345678910111213....#include &lt;klee/klee.h&gt;....int main(){ struct xfrm_userpolicy_info info; klee_make_symbolic(&amp;info, sizeof(info), \"info\"); unsigned int err = verify_newpolicy_info(&amp;info); klee_assume(err == 0);}.... 运行klee命令 1klee -silent-klee-assume --search=random-state xfrm_user.bc 发现klee无法初始化部分全局变量(这些全局变量存在于.h文件中)，patch注释即可,例如缺少kmalloc_cache和current_task，则注释掉内核如下代码 12345include/linux/slab.h:#ifndef CONFIG_SLOB//extern struct kmem_cache *kmalloc_caches[KMALLOC_SHIFT_HIGH + 1];#ifdef CONFIG_ZONE_DMA 12arch/x86/include/asm/current.h// DECLARE_PER_CPU(struct task_struct *, current_task); 重新运行上述命令，已经生成通过verify_newpolicy_info校验的testcase: 123456789101112xx@PC:~/LinuxKernel/klee-kernel/4.19/linux-4.19.126/bitcode-out/net/xfrm$ ls klee-lastassembly.ll info messages.txt run.istats run.stats test000001.ktest test000002.ktest test000003.ktest test000004.ktest warnings.txtxx@PC:~/LinuxKernel/klee-kernel/4.19/linux-4.19.126/bitcode-out/net/xfrm$ ktest-tool klee-last/test000004.ktest ktest file : 'klee-last/test000004.ktest'args : ['xfrm_user.bc']num objects: 1object 0: name: 'info'object 0: size: 168object 0: data: b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\n\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xf8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'object 0: hex : 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f80000000000000000000000object 0: text: ........................................................................................................................................................................ 组合多个bc文件linux内核中存在EXPORT_SYMBOL，其他模块可以调用它，klee可能无法调用到某些函数，由于我的目标是尽可能的少的改动源码，所以需要更加精细的提取编译命令，构建这些bc patch点12345678xx@PC:~/LinuxKernel/klee-kernel/4.19/linux-4.19.126$ vim include/linux/slab.hxx@PC:~/LinuxKernel/klee-kernel/4.19/linux-4.19.126$ vim include/net/net_namespace.hxx@PC:~/LinuxKernel/klee-kernel/4.19/linux-4.19.126$ vim include/linux/jiffies.hxx@PC:~/LinuxKernel/klee-kernel/4.19/linux-4.19.126$ vim include/linux/jiffies.hxx@PC:~/LinuxKernel/klee-kernel/4.19/linux-4.19.126$ vim include/linux/jiffies.hxx@PC:~/LinuxKernel/klee-kernel/4.19/linux-4.19.126$ vim include/linux/workqueue.hxx@PC:~/LinuxKernel/klee-kernel/4.19/linux-4.19.126$ vim include/linux/cred.hxx@PC:~/LinuxKernel/klee-kernel/4.19/linux-4.19.126$ vim include/linux/audit.h 出现了很严重的链接问题, 如果不patch上面的extern全局变量，则klee运行时会报无法初始化全局变量， 如果patch则llvm-link会出现多重定义， 如果对上述缺失的audit.c和xfrm使用同样的方法过滤，则无法通过编译， 如果使用wllvm生成的bc, llvm-link链接报-fshort-wchar错误 1llvm-link xfrm_user.bc xfrm_state.bc xfrm_algo.bc -o xfrm.bc 内核整体的Makefile中包含-fshort-wchar,需要删除这一行，下一节介绍如何正确组合多个bc文件 附录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;nlohmann/json.hpp&gt;#include &lt;fstream&gt;using json = nlohmann::json;inline bool ends_with(std::string const &amp; value, std::string const &amp; ending){ if (ending.size() &gt; value.size()) return false; return std::equal(ending.rbegin(), ending.rend(), value.rbegin());}int main() { std::ifstream stream(\"/home/xx/LinuxKernel/klee-kernel/4.19/linux-4.19.126/compile_commands.json\"); json dbs = json::parse(stream); std::vector&lt;std::string&gt; target={ \"cpu/common.c\", \"xfrm/xfrm_user.c\", }; std::vector&lt;std::string&gt; depends; std::string klee_cmd; for(auto &amp; compile : dbs){ auto &amp; arguments = compile[\"arguments\"]; std::string cmd; for(auto &amp; one_arg : arguments){ auto arg_str = one_arg.get&lt;std::string&gt;(); if(arg_str.find(\"Werror\") != std::string::npos){ continue; } else if(ends_with(arg_str, \".o\")){ arg_str=arg_str.substr(0, arg_str.find(\".o\"))+\".bc \"; arg_str += \"-g -c -emit-llvm\"; } else if(ends_with(arg_str, \".c\")){ arg_str = arg_str.substr(0, arg_str.find(\".c\"))+\"_klee.c \"; arg_str.insert(0, \"-D__CLANG_STDINT_H=1 \"); } else if(arg_str.find(\"-isystem\") != std::string::npos){ arg_str.insert(0, \"-I /usr/local/include \"); } else if(arg_str.find(\"-O2\") != std::string::npos){ arg_str = \"-O0\"; } else if(arg_str.find(\"-fshort-wchar\") != std::string::npos){ arg_str=\"\"; } cmd += arg_str + \" \"; } std::cout &lt;&lt; cmd &lt;&lt; std::endl; } return 0;} 使用klee为Linux内核生成module的测试用例构建module在上一篇文章中，介绍了给单个源码文件中的函数生成测试用例，但内核中很多函数会调用到其他文件中的函数，比如xfrm_user.c -&gt; xfrm_algo.c -&gt; xfrm_state.c这样的链，所以最好是能将多个相关bc文件合并在一起(尽量确保我们的目标函数是self-contain)。 解决方法就是通过llvm-link命令，但有一些细节需要处理： klee原始版本会强制对所有全局变量进行处理, 包括内核的extern全局变量 有的全局变量存在于汇编语言中，klee无法处理这样的llvm bitcode patch Klee如果我们仅仅想处理单个文件，直接patch内核中的extern变量为非extern变量,虽然这样工作量也很大；但是如果那样处理，llvm-link无法链接这些bc，会出现变量重定义的错误。 于是我尝试将缺失的全局变量定义的bc全部加入到llvm-link的链接过程，这时发现有的变量存在于内核汇编语言中，所以这条路走不通。 又只能回到klee的源码，看看能不能避免加载那些extern的全局变量，直接搜索”unable to load symbol”定位到如下函数，最开始尝试修改源码!addr时continue，但klee运行会崩溃，我注意到了addr = &amp;__dso_handle;这行，如果我自己分配一块内存，让klee以为自己找到了地址呢？ 1234567891011121314void Executor::initializeGlobals(ExecutionState &amp;state) {... void *addr; if (i-&gt;getName() == \"__dso_handle\") { addr = &amp;__dso_handle; // } else { addr = externalDispatcher-&gt;resolveSymbol(i-&gt;getName()); } if (!addr) klee_error(\"unable to load symbol(%s) while initializing globals.\", i-&gt;getName().data());...} 改成如下: 12345678910if (i-&gt;getName() == \"__dso_handle\") { addr = &amp;__dso_handle; // wtf ?} else { addr = externalDispatcher-&gt;resolveSymbol(i-&gt;getName());}if (!addr){ klee_warning(\"unable to load symbol(%s) while initializing globals.\", i-&gt;getName().data()); addr=other_pointer;&lt;-------------------新增} 成功运行，然后将xfrm_user和其他模块链接。 1llvm-link ./xfrm_algo.bc ./xfrm_state.bc ./extern_klee.bc ./xfrm_user.bc -o xfrm.bc 实现其他模块的函数内核内存分配函数和其他模块的函数需要自己实现，否则会影响klee效率，如果需要分配内存，则返回全局变量 123456789101112131415161718192021222324252627282930313233343536#include &lt;linux/slab.h&gt;#include &lt;linux/timer.h&gt;#include &lt;linux/interrupt.h&gt;#include &lt;net/xfrm.h&gt;struct xfrm_state state;void *kmem_cache_alloc(struct kmem_cache * cache, gfp_t flags){ return &amp;state;}void tasklet_hrtimer_init(struct tasklet_hrtimer *ttimer, enum hrtimer_restart (*function)(struct hrtimer *), clockid_t which_clock, enum hrtimer_mode mode){}void init_timer_key(struct timer_list *timer, void (*func)(struct timer_list *), unsigned int flags, const char *name, struct lock_class_key *key){}time64_t ktime_get_real_seconds(void){ return 0;}int crypto_has_alg(const char *name, u32 type, u32 mask){ return 1;}uint32_t buf_idx=0;char buf[0x10000];void *kmemdup(const void *src, size_t len, gfp_t gfp){ void* ret=buf+buf_idx; memcpy(ret, src, len); buf_idx+=len; return ret;} 测试modulexfrm模块对netlink的attr做了非常多校验，下面是构造netlink attr，并调用klee相关函数 12345678910111213141516171819202122232425262728int main(){ struct nlattr *attrs[XFRMA_MAX]; memset(attrs, 0, sizeof(void*) * XFRMA_MAX); uint8_t* ptr = global_buffer; struct net net_local; memset(&amp;net_local, 0, sizeof(net_local)); struct xfrm_usersa_info info; uint8_t has[XFRMA_MAX]; klee_make_symbolic(global_buffer, 10000 , \"global_buffer\"); klee_make_symbolic(&amp;info, sizeof(info) , \"info\"); klee_make_symbolic(has, XFRMA_MAX , \"has\"); uint16_t item_size = 200 - sizeof(struct nlattr); //不要给attr指针数组的每一项都赋值，因为存在冲突，应该假定不知道哪些attr需要赋值， for(int i=0;i&lt;XFRMA_MAX;i++){ if(has[i]){ attrs[i]=(struct nlattr*)(ptr); ((struct nlattr*)(ptr))-&gt;nla_len = item_size; ptr += 200; } } klee_assume(verify_newsa_info(&amp;info, attrs) == 0); int err=0; //klee_assume(err == 0); klee_assume(xfrm_state_construct(&amp;net_local, &amp;info, attrs, &amp;err)); return 0;} 构建完整的klee如果不使用klee提供的uclibc，则无法使用strcmp，所以需要构建完整的klee 1cmake .. -DENABLE_POSIX_RUNTIME=ON -DENABLE_KLEE_UCLIBC=ON -DKLEE_UCLIBC_PATH=/usr/x86_64-linux-uclibc/usr 运行： 1klee --libc=uclibc --posix-runtime -silent-klee-assume --search=dfs ./xfrm.bc 构建external 1clang-10 -c -Wp,-MD,net/xfrm/.xfrm_user.o.d -nostdinc -I /usr/local/include -isystem /usr/lib/llvm-10/lib/clang/10.0.0/include -I../arch/x86/include -I./arch/x86/include/generated -I../include -I./include -I../arch/x86/include/uapi -I./arch/x86/include/generated/uapi -I../include/uapi -I./include/generated/uapi -include ../include/linux/kconfig.h -include ../include/linux/compiler_types.h -I../net/xfrm -Inet/xfrm -D__KERNEL__ -Qunused-arguments -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -Wno-format-security -std=gnu89 -no-integrated-as -fno-PIE -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -mno-avx -m64 -mno-80387 -mstack-alignment=8 -mtune=generic -mno-red-zone -mcmodel=kernel -funit-at-a-time -DCONFIG_AS_CFI=1 -DCONFIG_AS_CFI_SIGNAL_FRAME=1 -DCONFIG_AS_CFI_SECTIONS=1 -DCONFIG_AS_FXSAVEQ=1 -DCONFIG_AS_SSSE3=1 -DCONFIG_AS_CRC32=1 -DCONFIG_AS_AVX=1 -DCONFIG_AS_AVX2=1 -DCONFIG_AS_AVX512=1 -DCONFIG_AS_SHA1_NI=1 -DCONFIG_AS_SHA256_NI=1 -pipe -Wno-sign-compare -fno-asynchronous-unwind-tables -mretpoline-external-thunk -fno-delete-null-pointer-checks -Wno-int-in-bool-context -Wno-address-of-packed-member -O0 -Wframe-larger-than=2048 -fstack-protector-strong -Wno-format-invalid-specifier -Wno-gnu -Wno-tautological-compare -mno-global-merge -Wno-unused-const-variable -fomit-frame-pointer -Wdeclaration-after-statement -Wno-pointer-sign -Wno-array-bounds -fno-strict-overflow -fno-merge-all-constants -fno-stack-check -fmacro-prefix-map=../= -fcf-protection=none -Wno-initializer-overrides -Wno-unused-value -Wno-format -Wno-sign-compare -Wno-format-zero-length -Wno-uninitialized -DKBUILD_BASENAME=\"xfrm_user\" -DKBUILD_MODNAME=\"\\\"xfrm_user\\\"\" -o net/xfrm/extern_klee.bc -g -c -emit-llvm -D__CLANG_STDINT_H=1 ../net/xfrm/extern_klee.c","link":"/2020/08/14/klee_linux/"}],"tags":[{"name":"symbolic execution","slug":"symbolic-execution","link":"/tags/symbolic-execution/"}],"categories":[]}